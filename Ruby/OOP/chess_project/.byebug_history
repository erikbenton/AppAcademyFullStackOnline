exit
n
display piece.class
s
n
display other_pieces_classes = other_pieces.map { |piece| piece.class }
n
s
exit
n
display piece.class
display piece.moves
s
n
display king_moves
n
display king.pos
n
s
exit
c
game.board.checkmate?(:black)
color
s
c
color
n
display king_moves
n
s
game.board.checkmate?(:black)
game.board.in_check?(:black)
game.board.checkmate?(game.current_player.color)
exit
xit
game.board.checkmate?(game.current_player.color)
exit
game.board.checkmate?(game.current_player.color)
exit
king_moves
n
display king.pos
n
in_check?(color)
color
s
c
game.current_player.color
c
game.current_player.color
game.board.checkmate?(game.current_player.color)
n
exit
c
n
exit
c
disp.cursor.selected.valid_moves
disp.cursor.selected
disp.cursor
n
display @board[@cursor_pos]
exit
c
exit
unless piece
piece
exit
c
exit
new_board.in_check?(:white)
self.color
new_board.render
n
possible_moves
self.class
exit
c
exit
c
exit
cc
c
cc
c
cc
c
exit
display king_pos
c
exit
next_pos
n
self.class
c
n
display king_pos
exit
self.class
self.pos
c
king_pos
exit
display self.pos
display next_pos
n
c
exit
display disp.cursor.cursor_pos
n
display new_pos
display @cursor_pos
exit
disp.cursor
n
display cursor_pos
display new_pos
exit
c
n
exit
c
display cursor_pos
c
n
new_pos
exit
s
display new_pos
exit
STDIN.echo = true
STDIN.cooked!
STDIN.echo = true
n
display input
n
exit
n
<<<<<<< HEAD
c
exit
self[start_pos].pos
exit
new_piece.class
c
new_piece.class
c
display new_piece.pos
c
new_piece.pos
c
display new_board[[0,0]]
n
display new_board[new_piece.pos]
new_piece.class
piece.pos
exit
new_board
n
pieces
=======
exit
n
display right
display left
n
display dir
exit
self.board[next_pos].class
n
dy
dx
n
self.class
c
self.class
dy
dx
n
display next_pos
exit
n
display moves
n
exit
self.board.valid_pos?(future_pos)
future_pos
c
exit
n
s
n
s
c
exit
n
pos
s
n
s
n
s
n
next_pos
n
start
n
start
s
display moves
@@HORIZONTAL_DIRS
exit
color.nil?
display color
>>>>>>> defdb1bd380296168ae705a2eba3027658552c93
n
pos
